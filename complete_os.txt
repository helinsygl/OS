# GTU-C312 Compact Operating System
# Fixed instruction gaps - All sequential
# Author: helinsygl  
# Date: 2025-06-04 11:55:30 UTC

Begin Data Section
# System Registers (0-20)
0 100         # PC - OS starts here
1 15000       # SP
2 0           # System call result
3 0           # Instruction counter
4 0           # Current thread ID (0=OS, 1-3=threads)
5 3           # Total threads
6 1           # Round robin index
7 5           # Time slice (reduced for faster switching)
8 0           # Context switch counter
9 0           # Time slice counter
10 0          # System state

# Thread Control Blocks
50 1          # Thread 1 ID
51 1000       # Thread 1 start address
52 1          # Thread 1 state (1=ready)
60 2          # Thread 2 ID  
61 2000       # Thread 2 start address
62 1          # Thread 2 state
70 3          # Thread 3 ID
71 3000       # Thread 3 start address
72 1          # Thread 3 state

# Working variables
80 0          # Current TCB base
81 0          # Next thread
82 0          # Temp storage

# Thread data areas
1100 5        # Thread 1: Array size
1101 64       # arr[0]
1102 34       # arr[1]
1103 25       # arr[2]
1104 12       # arr[3]
1105 22       # arr[4]

2100 25       # Thread 2: Search key
2101 10       # arr[0]
2102 25       # arr[1] <- Target
2103 30       # arr[2]
2104 45       # arr[3]
2105 50       # arr[4]

3100 5        # Thread 3: Factorial input
3101 1        # Factorial result
End Data Section

Begin Instruction Section
# ===== OS KERNEL - NO GAPS! =====
100 SYSCALL PRN 9999      # OS boot
101 SET 1 52              # Thread 1 ready
102 SET 1 62              # Thread 2 ready
103 SET 1 72              # Thread 3 ready
104 SET 0 9               # Reset timer
105 SET 1 4               # Start with thread 1

# MAIN SCHEDULER LOOP
106 CALL 120              # Schedule next thread
107 CALL 140              # Context switch
108 CALL 160              # Check time slice
109 CALL 180              # Check if all done
110 JIF 10 106            # Continue if running
111 SYSCALL PRN 8888      # OS shutdown
112 HLT                   # End OS

# Padding to avoid gaps
113 SET 0 0               # NOP
114 SET 0 0               # NOP
115 SET 0 0               # NOP
116 SET 0 0               # NOP
117 SET 0 0               # NOP
118 SET 0 0               # NOP
119 SET 0 0               # NOP

# SCHEDULER (120-139)
120 CPY 6 81              # Get round robin index
121 SET 50 80             # Base TCB address
122 CPY 81 82             # Thread ID
123 ADD 82 -1             # Convert to index
124 SET 10 82             # TCB offset
125 ADDI 80 82            # Calculate TCB address
126 ADD 6 1               # Next thread
127 CPY 6 82              # Check bounds
128 SET 3 81              # Max threads
129 SUBI 82 81            # Compare
130 JIF 82 135            # If valid, continue
131 SET 1 6               # Reset to thread 1
132 SET 120 0             # Restart scheduler
133 SET 0 0               # NOP
134 SET 0 0               # NOP
135 CPY 80 4              # Set current thread
136 RET
137 SET 0 0               # NOP
138 SET 0 0               # NOP
139 SET 0 0               # NOP

# CONTEXT SWITCH (140-159)
140 CPY 4 81              # Current thread ID
141 SET 50 80             # Base TCB
142 CPY 81 82             # Thread ID
143 ADD 82 -1             # Convert to index
144 SET 10 81             # TCB size
145 ADDI 80 81            # TCB address
146 ADD 80 1              # Point to start address
147 CPYI 80 82            # Get start address
148 USER 82               # Switch to user mode
149 RET
150 SET 0 0               # NOP
151 SET 0 0               # NOP
152 SET 0 0               # NOP
153 SET 0 0               # NOP
154 SET 0 0               # NOP
155 SET 0 0               # NOP
156 SET 0 0               # NOP
157 SET 0 0               # NOP
158 SET 0 0               # NOP
159 SET 0 0               # NOP

# TIME SLICE CHECK (160-179)
160 ADD 9 1               # Increment timer
161 CPY 9 81              # Get timer
162 SUBI 81 7             # Compare with time slice
163 JIF 81 170            # If not expired, continue
164 SET 0 9               # Reset timer
165 ADD 8 1               # Increment context switches
166 RET
167 SET 0 0               # NOP
168 SET 0 0               # NOP
169 SET 0 0               # NOP
170 RET
171 SET 0 0               # NOP
172 SET 0 0               # NOP
173 SET 0 0               # NOP
174 SET 0 0               # NOP
175 SET 0 0               # NOP
176 SET 0 0               # NOP
177 SET 0 0               # NOP
178 SET 0 0               # NOP
179 SET 0 0               # NOP

# CHECK ALL DONE (180-199)
180 CPY 52 81             # Thread 1 state
181 SET 0 82              # Terminated state
182 SUBI 81 82            # Compare
183 JIF 81 190            # If not terminated, still running
184 CPY 62 81             # Thread 2 state
185 SUBI 81 82            # Compare
186 JIF 81 190            # If not terminated, still running
187 CPY 72 81             # Thread 3 state
188 SUBI 81 82            # Compare
189 JIF 81 190            # If not terminated, still running
190 SET 1 10              # All done
191 RET
192 SET 0 0               # NOP
193 SET 0 0               # NOP
194 SET 0 0               # NOP
195 SET 0 0               # NOP
196 SET 0 0               # NOP
197 SET 0 0               # NOP
198 SET 0 0               # NOP
199 SET 0 0               # NOP

# ===== THREAD 1: SIMPLE SORT (1000-1999) =====
1000 SYSCALL PRN 1111     # Thread 1 start
1001 SYSCALL PRN 1101     # Print original array
1002 SYSCALL PRN 1102
1003 SYSCALL PRN 1103
1004 SYSCALL PRN 1104
1005 SYSCALL PRN 1105
1006 SYSCALL YIELD        # Yield to other threads

# Simple bubble sort (2 passes)
1007 CPY 1101 81          # val1 = arr[0]
1008 CPY 1102 82          # val2 = arr[1]
1009 SUBI 81 82           # compare
1010 JIF 81 1015          # if arr[0] <= arr[1], skip
1011 CPY 1101 80          # temp = arr[0]
1012 CPY 1102 1101        # arr[0] = arr[1]
1013 CPY 80 1102          # arr[1] = temp
1014 SYSCALL YIELD        # Yield

1015 CPY 1102 81          # val1 = arr[1]
1016 CPY 1103 82          # val2 = arr[2]
1017 SUBI 81 82           # compare
1018 JIF 81 1023          # if arr[1] <= arr[2], skip
1019 CPY 1102 80          # temp = arr[1]
1020 CPY 1103 1102        # arr[1] = arr[2]
1021 CPY 80 1103          # arr[2] = temp
1022 SYSCALL YIELD        # Yield

1023 CPY 1103 81          # val1 = arr[2]
1024 CPY 1104 82          # val2 = arr[3]
1025 SUBI 81 82           # compare
1026 JIF 81 1031          # if arr[2] <= arr[3], skip
1027 CPY 1103 80          # temp = arr[2]
1028 CPY 1104 1103        # arr[2] = arr[3]
1029 CPY 80 1104          # arr[3] = temp
1030 SYSCALL YIELD        # Yield

1031 CPY 1104 81          # val1 = arr[3]
1032 CPY 1105 82          # val2 = arr[4]
1033 SUBI 81 82           # compare
1034 JIF 81 1039          # if arr[3] <= arr[4], skip
1035 CPY 1104 80          # temp = arr[3]
1036 CPY 1105 1104        # arr[3] = arr[4]
1037 CPY 80 1105          # arr[4] = temp
1038 SYSCALL YIELD        # Yield

# Second pass
1039 CPY 1101 81          # Repeat first pass
1040 CPY 1102 82
1041 SUBI 81 82
1042 JIF 81 1047
1043 CPY 1101 80
1044 CPY 1102 1101
1045 CPY 80 1102
1046 SYSCALL YIELD

1047 CPY 1102 81
1048 CPY 1103 82
1049 SUBI 81 82
1050 JIF 81 1055
1051 CPY 1102 80
1052 CPY 1103 1102
1053 CPY 80 1103
1054 SYSCALL YIELD

1055 CPY 1103 81
1056 CPY 1104 82
1057 SUBI 81 82
1058 JIF 81 1063
1059 CPY 1103 80
1060 CPY 1104 1103
1061 CPY 80 1104
1062 SYSCALL YIELD

# Print sorted array
1063 SYSCALL PRN 1101     # Print sorted
1064 SYSCALL PRN 1102
1065 SYSCALL PRN 1103
1066 SYSCALL PRN 1104
1067 SYSCALL PRN 1105
1068 SET 0 52              # Set thread 1 terminated
1069 SYSCALL HLT

# ===== THREAD 2: LINEAR SEARCH (2000-2999) =====
2000 SYSCALL PRN 2222     # Thread 2 start
2001 SET 0 81             # index = 0
2002 SET -1 82            # result = -1

# Search loop
2003 SET 2101 80          # Base address
2004 ADDI 80 81           # current address
2005 CPYI 80 80           # current value
2006 SUBI 80 2100         # compare with search key
2007 JIF 80 2012          # if not found, continue
2008 CPY 81 82            # result = index
2009 SET 2015 0           # jump to print
2010 SYSCALL YIELD        # Yield
2011 SET 0 0              # NOP

2012 ADD 81 1             # index++
2013 SET 5 80             # array size
2014 SUBI 81 80           # compare with size
2015 SYSCALL YIELD        # Yield
2016 JIF 81 2003          # continue if index < size

# Print result
2017 SYSCALL PRN 82       # Print result
2018 SYSCALL PRN 2100     # Print search key
2019 SET 0 62             # Set thread 2 terminated
2020 SYSCALL HLT

# ===== THREAD 3: FACTORIAL (3000-3999) =====
3000 SYSCALL PRN 3333     # Thread 3 start
3001 SET 1 81             # counter = 1
3002 SET 1 82             # result = 1

# Factorial loop
3003 ADDI 82 81           # result *= counter
3004 ADD 81 1             # counter++
3005 SUBI 81 3100         # compare with n
3006 SYSCALL YIELD        # Yield
3007 JIF 81 3003          # continue if counter <= n

3008 SYSCALL PRN 82       # Print factorial result
3009 SET 0 72             # Set thread 3 terminated
3010 SYSCALL HLT
End Instruction Section