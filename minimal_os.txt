# GTU-C312 Fixed Minimal OS
# Corrected USER instruction addresses
# Author: helinsygl  
# Date: 2025-06-04 12:00:15 UTC

Begin Data Section
# System Registers
0 100         # PC - OS starts here
1 15000       # SP
2 0           # Syscall result
3 0           # Instruction counter
4 1           # Current thread ID (1, 2, or 3)
5 0           # Thread switch counter

# Thread states (1=ready, 0=terminated)
50 1          # Thread 1 state
51 1          # Thread 2 state  
52 1          # Thread 3 state

# Thread START ADDRESSES - Critical fix!
60 1000       # Thread 1 start address
61 2000       # Thread 2 start address
62 3000       # Thread 3 start address

# Thread data
1000 64       # Thread 1 data: array element 1
1001 34       # Thread 1 data: array element 2
1002 25       # Thread 1 data: array element 3

2000 25       # Thread 2 data: search key
2001 10       # Thread 2 data: array[0]
2002 25       # Thread 2 data: array[1] <- target

3000 5        # Thread 3 data: factorial input
3001 1        # Thread 3 data: factorial result
End Data Section

Begin Instruction Section
# ===== OS KERNEL (100-199) =====
100 SYSCALL PRN 9999      # OS boot message
101 SET 5 5               # Max time slice
102 SET 0 5               # Reset counter
103 SET 1 4               # Start with thread 1

# MAIN SCHEDULER LOOP
104 CPY 4 10              # Get current thread
105 SET 1 11              # Compare value
106 CPY 10 12             # Thread ID to temp
107 SUBI 12 11            # Compare with 1
108 JIF 12 120            # If thread 1, jump to thread 1

109 SET 2 11              # Compare value
110 CPY 10 12             # Thread ID to temp
111 SUBI 12 11            # Compare with 2
112 JIF 12 140            # If thread 2, jump to thread 2

113 SET 3 11              # Compare value
114 CPY 10 12             # Thread ID to temp
115 SUBI 12 11            # Compare with 3
116 JIF 12 160            # If thread 3, jump to thread 3

# Next thread in round robin
117 ADD 4 1               # Next thread
118 CPY 4 12              # Check bounds
119 SET 3 11              # Max threads
120 SUBI 12 11            # Compare
121 JIF 12 125            # If valid, continue
122 SET 1 4               # Reset to thread 1
123 SET 104 0             # Jump back to scheduler

# Check if all threads done
125 CPY 50 10             # Thread 1 state
126 CPY 51 11             # Thread 2 state
127 CPY 52 12             # Thread 3 state
128 ADD 10 11             # Sum states
129 ADD 12 10             # Total active threads
130 JIF 10 104            # If any active, continue
131 SYSCALL PRN 8888      # OS shutdown message
132 HLT                   # End OS

# Thread dispatch points - FIXED!
120 USER 60               # Execute Thread 1 (address stored in 60)
121 SET 104 0             # Return to scheduler

140 USER 61               # Execute Thread 2 (address stored in 61)
141 SET 104 0             # Return to scheduler

160 USER 62               # Execute Thread 3 (address stored in 62)
161 SET 104 0             # Return to scheduler

# ===== THREAD 1: SIMPLE SORT (1000-1999) =====
1000 SYSCALL PRN 1111     # Thread 1 start marker
1001 SYSCALL PRN 1000     # Print original values
1002 SYSCALL PRN 1001
1003 SYSCALL PRN 1002

# Simple comparison and swap
1004 CPY 1000 10          # val1 = arr[0]
1005 CPY 1001 11          # val2 = arr[1]
1006 SUBI 10 11           # compare
1007 JIF 10 1012          # if arr[0] <= arr[1], skip swap
1008 CPY 1000 12          # temp = arr[0]
1009 CPY 1001 1000        # arr[0] = arr[1]
1010 CPY 12 1001          # arr[1] = temp
1011 SYSCALL YIELD        # Yield to other threads

1012 CPY 1001 10          # val1 = arr[1]
1013 CPY 1002 11          # val2 = arr[2]
1014 SUBI 10 11           # compare
1015 JIF 10 1020          # if arr[1] <= arr[2], skip swap
1016 CPY 1001 12          # temp = arr[1]
1017 CPY 1002 1001        # arr[1] = arr[2]
1018 CPY 12 1002          # arr[2] = temp
1019 SYSCALL YIELD        # Yield to other threads

1020 CPY 1000 10          # val1 = arr[0] (second pass)
1021 CPY 1001 11          # val2 = arr[1]
1022 SUBI 10 11           # compare
1023 JIF 10 1028          # if arr[0] <= arr[1], skip swap
1024 CPY 1000 12          # temp = arr[0]
1025 CPY 1001 1000        # arr[0] = arr[1]
1026 CPY 12 1001          # arr[1] = temp
1027 SYSCALL YIELD        # Yield to other threads

# Print sorted results
1028 SYSCALL PRN 1000     # Print sorted values
1029 SYSCALL PRN 1001
1030 SYSCALL PRN 1002
1031 SET 0 50             # Set thread 1 terminated
1032 SYSCALL HLT          # Thread 1 done

# ===== THREAD 2: LINEAR SEARCH (2000-2999) =====
2000 SYSCALL PRN 2222     # Thread 2 start marker
2001 SET 0 10             # index = 0
2002 SET -1 11            # result = -1 (not found)

# Search in small array
2003 SET 2001 12          # Base address
2004 ADDI 12 10           # current address = base + index
2005 CPYI 12 13           # current value = array[index]
2006 SUBI 13 2000         # compare with search key
2007 JIF 13 2012          # if not equal, continue
2008 CPY 10 11            # result = index
2009 SET 2015 0           # jump to print result

2012 ADD 10 1             # index++
2013 SET 2 12             # array size
2014 SUBI 10 12           # compare with size
2015 SYSCALL YIELD        # Yield to other threads
2016 JIF 10 2003          # continue if index < size

# Print result
2017 SYSCALL PRN 11       # Print search result
2018 SYSCALL PRN 2000     # Print search key
2019 SET 0 51             # Set thread 2 terminated
2020 SYSCALL HLT          # Thread 2 done

# ===== THREAD 3: FACTORIAL (3000-3999) =====
3000 SYSCALL PRN 3333     # Thread 3 start marker
3001 SET 1 10             # counter = 1
3002 SET 1 11             # result = 1

# Simple factorial loop
3003 ADDI 11 10           # result *= counter
3004 ADD 10 1             # counter++
3005 SUBI 10 3000         # compare with n
3006 SYSCALL YIELD        # Yield to other threads
3007 JIF 10 3003          # continue if counter <= n

3008 SYSCALL PRN 11       # Print factorial result
3009 SET 0 52             # Set thread 3 terminated
3010 SYSCALL HLT          # Thread 3 done
End Instruction Section